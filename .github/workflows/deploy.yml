name: 在服务器上构建并部署

on:
  push:
    branches:
      - main

# 定义环境变量
env:
  APP_NAME: evolve-file-processor
  API_URL: ${{ secrets.API_URL || 'http://localhost:8000' }}

jobs:
  deploy-on-server:
    name: 在腾讯云服务器上构建和部署
    runs-on: ubuntu-latest
    timeout-minutes: 40  # 增加超时时间
    steps:
      - name: 检出代码
        uses: actions/checkout@v3
        with:
          fetch-depth: 0  # 获取完整代码库
      
      - name: 设置Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
          
      - name: 安装依赖
        run: |
          pip install --upgrade pip
          pip install poetry
          
      - name: 确保使用轻量级依赖
        run: |
          # 确保脚本可执行
          chmod +x scripts/generate_requirements.sh
          # 生成轻量级依赖
          ./scripts/generate_requirements.sh
          # 检查是否包含大型依赖
          echo "检查是否包含大型依赖:"
          grep -E 'torch|transformers|numpy|scipy|unstructured|easyocr' requirements.txt || echo "✓ 依赖列表已精简，未包含大型ML库"
      
      - name: 确保.env文件不被删除并准备缓存目录
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.CVM_HOST }}
          username: ${{ secrets.CVM_USERNAME }}
          key: ${{ secrets.CVM_SSH_PRIVATE_KEY }}
          script: |
            mkdir -p ~/${{ secrets.CVM_USERNAME }}/evolve-file-processor
            cd ~/${{ secrets.CVM_USERNAME }}/evolve-file-processor
            
            # 备份.env文件（如果存在）
            if [ -f .env ]; then
              cp .env ~/${{ secrets.CVM_USERNAME }}/.env.backup
              echo ".env文件已备份"
            else
              echo "警告：未找到.env文件，请确保有一个可用的.env文件"
            fi
            
            # 创建Docker缓存目录
            mkdir -p ~/docker_cache
            
            # 设置APT缓存
            sudo mkdir -p /var/cache/apt/archives
            sudo chmod 777 /var/cache/apt/archives
            
            # 将当前的requirements.txt复制出来（如果存在）
            if [ -f requirements.txt ]; then
              cp requirements.txt ~/${{ secrets.CVM_USERNAME }}/requirements.backup
            fi
        
      - name: 复制项目代码到服务器(保留缓存文件)
        uses: appleboy/scp-action@master
        with:
          host: ${{ secrets.CVM_HOST }}
          username: ${{ secrets.CVM_USERNAME }}
          key: ${{ secrets.CVM_SSH_PRIVATE_KEY }}
          source: "./*"
          target: "~/${{ secrets.CVM_USERNAME }}/evolve-file-processor"
          rm: false  # 不删除目标目录中的文件，只覆盖
          strip_components: 0
          
      - name: 复制Nginx配置文件到服务器
        uses: appleboy/scp-action@master
        with:
          host: ${{ secrets.CVM_HOST }}
          username: ${{ secrets.CVM_USERNAME }}
          key: ${{ secrets.CVM_SSH_PRIVATE_KEY }}
          source: "nginx/file-processor.conf"
          target: "~/${{ secrets.CVM_USERNAME }}/evolve-file-processor"

      - name: 在服务器上构建和部署
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.CVM_HOST }}
          username: ${{ secrets.CVM_USERNAME }}
          key: ${{ secrets.CVM_SSH_PRIVATE_KEY }}
          command_timeout: 30m
          script: |
            set -e
            
            # 1. 进入项目目录
            cd ~/${{ secrets.CVM_USERNAME }}/evolve-file-processor
            
            # 2. 恢复.env文件
            if [ -f ~/${{ secrets.CVM_USERNAME }}/.env.backup ]; then
              cp ~/${{ secrets.CVM_USERNAME }}/.env.backup .env
              echo ".env文件已恢复"
            fi
            
            # 3. 检查是否需要重新构建
            REBUILD=false
            if [ -f ~/${{ secrets.CVM_USERNAME }}/requirements.backup ]; then
              if ! diff -q ~/${{ secrets.CVM_USERNAME }}/requirements.backup requirements.txt &>/dev/null; then
                echo "requirements.txt已更改，需要重新构建"
                REBUILD=true
              else
                echo "requirements.txt未更改，尝试复用现有镜像"
              fi
              # 保存当前版本用于下次比较
              cp requirements.txt ~/${{ secrets.CVM_USERNAME }}/requirements.backup
            else
              echo "未找到之前的requirements.backup，将进行完整构建"
              REBUILD=true
              cp requirements.txt ~/${{ secrets.CVM_USERNAME }}/requirements.backup
            fi
            
            # 4. 检查.env文件是否存在
            if [ ! -f .env ]; then
              echo "错误: 服务器上不存在.env文件！请先创建此文件"
              exit 1
            else
              echo ".env文件已存在，验证配置中..."
              
              # 检查必要配置是否存在（不显示内容）
              if ! grep -q "DATABASE_URL" .env; then
                echo "错误: .env文件缺少DATABASE_URL配置"
                exit 1
              fi
              
              if ! grep -q "POSTGRES_USER" .env; then
                echo "错误: .env文件缺少POSTGRES_USER配置"
                exit 1
              fi
              
              if ! grep -q "POSTGRES_PASSWORD" .env; then
                echo "错误: .env文件缺少POSTGRES_PASSWORD配置"
                exit 1
              fi
              
              if ! grep -q "POSTGRES_DB" .env; then
                echo "错误: .env文件缺少POSTGRES_DB配置"
                exit 1
              fi
              
              # 检查数据库连接是否指向正确的主机名
              if grep "localhost" .env | grep -q "DATABASE_URL"; then
                echo "警告: 发现DATABASE_URL使用localhost，临时修改为db"
                sed -i 's/localhost/db/g' .env
              fi
              
              echo ".env配置验证完成"
            fi
            
            # 5. 配置Docker设置以优化构建
            echo "配置Docker构建优化..."
            sudo mkdir -p /etc/docker
            if [ ! -f /etc/docker/daemon.json ]; then
              sudo tee /etc/docker/daemon.json > /dev/null << 'EOL'
            {
              "registry-mirrors": ["https://mirror.ccs.tencentyun.com"],
              "max-concurrent-downloads": 10,
              "log-driver": "json-file",
              "log-opts": {
                "max-size": "100m"
              },
              "storage-driver": "overlay2"
            }
            EOL
              sudo systemctl restart docker || sudo service docker restart
            fi
            
            # 6. 停止并清理所有相关容器、网络和卷
            echo "停止并清理之前的容器和相关资源..."
            # 先停止所有容器
            docker-compose down --remove-orphans || true
            
            # 尝试获取和停止可能仍在运行的相关容器
            RELATED_CONTAINERS=$(docker ps -a | grep evolve-file-processor | awk '{print $1}' || true)
            if [ ! -z "$RELATED_CONTAINERS" ]; then
              echo "发现相关容器，正在停止和移除："
              docker stop $RELATED_CONTAINERS || true
              docker rm $RELATED_CONTAINERS || true
            fi
            
            # 检查5432端口是否被占用，如果是则尝试释放
            PORT_PROCESS=$(sudo lsof -i :5432 | grep LISTEN | awk '{print $2}' || true)
            if [ ! -z "$PORT_PROCESS" ]; then
              echo "发现端口5432被进程${PORT_PROCESS}占用，尝试终止..."
              sudo kill -9 $PORT_PROCESS || true
              sleep 2
            fi
            
            # 清理无用的网络
            docker network prune -f
            
            # 查看端口状态
            echo "检查端口5432状态："
            sudo lsof -i :5432 || echo "端口5432当前空闲"
            
            # 修改docker-compose.yml使用不同的数据库端口（如果需要）
            if sudo lsof -i :5432 | grep LISTEN; then
              echo "警告：端口5432仍被占用，修改为使用5433端口"
              sed -i 's/5432:5432/5433:5432/g' docker-compose.yml
              # 同时更新.env中的数据库URL
              sed -i 's/:5432/:5433/g' .env
            fi
            
            # 7. 在本地构建Docker镜像（仅在需要时）
            if [ "$REBUILD" = true ] || ! docker image inspect evolve-file-processor:latest &>/dev/null; then
              echo "开始构建Docker镜像..."
              # 使用Docker构建缓存
              docker build --build-arg BUILDKIT_INLINE_CACHE=1 \
                          --cache-from evolve-file-processor:latest \
                          -t evolve-file-processor:latest .
              echo "Docker镜像构建完成"
            else
              echo "复用现有Docker镜像，跳过构建步骤"
            fi
            
            # 8. 启动服务
            echo "启动服务..."
            export IMAGE_NAME=evolve-file-processor
            export IMAGE_TAG=latest
            
            # 使用--force-recreate确保容器被重新创建
            docker-compose up -d --force-recreate
            
            # 9. 检查容器状态
            echo "查看容器状态..."
            docker-compose ps
            
            # 10. 等待数据库就绪
            echo "等待数据库就绪..."
            for i in {1..12}; do
              if docker-compose exec -T db pg_isready -U postgres &>/dev/null; then
                echo "数据库已就绪!"
                break
              fi
              echo "等待数据库就绪... 尝试 $i/12"
              sleep 5
              if [ $i -eq 12 ]; then
                echo "警告：数据库启动超时，但将继续部署流程"
              fi
            done
            
            # 11. 复制Nginx配置
            echo "复制Nginx配置..."
            sudo cp -f nginx/file-processor.conf /etc/nginx/conf.d/file-processor.evolving.team.conf || echo "警告：Nginx配置失败，可能需要手动配置"
            
            # 12. 确保Certbot已安装
            if ! command -v certbot &> /dev/null; then
                echo "安装Certbot..."
                sudo apt-get update
                sudo apt-get install -y certbot python3-certbot-nginx
            fi
            
            # 13. 申请/更新SSL证书（如果需要）
            if [ ! -d "/etc/letsencrypt/live/file-processor.evolving.team" ]; then
                echo "申请新的SSL证书..."
                sudo certbot --nginx -d file-processor.evolving.team --non-interactive --agree-tos -m admin@evolving.team || echo "证书申请失败，暂时使用HTTP"
            else
                echo "检查证书更新..."
                sudo certbot renew --nginx --non-interactive || echo "证书更新失败，使用现有证书"
            fi
            
            # 14. 检查Nginx配置并重新加载
            echo "检查并重新加载Nginx配置..."
            sudo nginx -t && sudo systemctl reload nginx
            
            # 15. 运行数据库迁移
            echo "运行数据库迁移..."
            docker-compose exec -T api alembic upgrade head || echo "数据库迁移失败，请手动检查"
            
            # 16. 清理不再使用的Docker镜像
            echo "清理未使用的Docker镜像..."
            docker image prune -f
            
            echo "部署完成!"
      
      # 等待服务启动
      - name: 等待服务启动
        run: sleep 15
      
      # 简单检查服务状态
      - name: 检查API服务
        run: |
          echo "检查API服务状态..."
          curl -s ${{ env.API_URL }}/health || echo "警告: 无法连接到API服务" 