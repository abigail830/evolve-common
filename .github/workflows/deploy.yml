name: 在服务器上构建并部署

on:
  push:
    branches:
      - main

# 定义环境变量
env:
  APP_NAME: evolve-file-processor
  API_URL: ${{ secrets.API_URL || 'http://localhost:8000' }}

jobs:
  deploy-on-server:
    name: 在腾讯云服务器上构建和部署
    runs-on: ubuntu-latest
    timeout-minutes: 40  # 增加超时时间
    steps:
      - name: 检出代码
        uses: actions/checkout@v3
        with:
          fetch-depth: 0  # 获取完整代码库
      
      - name: 设置Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
          
      - name: 安装依赖
        run: |
          pip install --upgrade pip
          pip install poetry
          
      - name: 确保使用轻量级依赖
        run: |
          # 确保脚本可执行
          chmod +x scripts/generate_requirements.sh
          # 生成轻量级依赖
          ./scripts/generate_requirements.sh
          # 检查是否包含大型依赖
          echo "检查是否包含大型依赖:"
          grep -E 'torch|transformers|numpy|scipy|unstructured|easyocr' requirements.txt || echo "✓ 依赖列表已精简，未包含大型ML库"
      
      - name: 确保.env文件不被删除并准备缓存目录
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.CVM_HOST }}
          username: ${{ secrets.CVM_USERNAME }}
          key: ${{ secrets.CVM_SSH_PRIVATE_KEY }}
          script: |
            mkdir -p ~/${{ secrets.CVM_USERNAME }}/evolve-file-processor
            cd ~/${{ secrets.CVM_USERNAME }}/evolve-file-processor
            
            # 备份.env文件（如果存在）
            if [ -f .env ]; then
              cp .env ~/${{ secrets.CVM_USERNAME }}/.env.backup
              echo ".env文件已备份"
            else
              echo "警告：未找到.env文件，请确保有一个可用的.env文件"
            fi
            
            # 创建Docker缓存目录
            mkdir -p ~/docker_cache
            
            # 设置APT缓存
            sudo mkdir -p /var/cache/apt/archives
            sudo chmod 777 /var/cache/apt/archives
            
            # 将当前的requirements.txt复制出来（如果存在）
            if [ -f requirements.txt ]; then
              cp requirements.txt ~/${{ secrets.CVM_USERNAME }}/requirements.backup
            fi
        
      - name: 复制项目代码到服务器(保留缓存文件)
        uses: appleboy/scp-action@master
        with:
          host: ${{ secrets.CVM_HOST }}
          username: ${{ secrets.CVM_USERNAME }}
          key: ${{ secrets.CVM_SSH_PRIVATE_KEY }}
          source: "./*"
          target: "~/${{ secrets.CVM_USERNAME }}/evolve-file-processor"
          rm: false  # 不删除目标目录中的文件，只覆盖
          strip_components: 0
          
      - name: 复制Nginx配置文件到服务器
        uses: appleboy/scp-action@master
        with:
          host: ${{ secrets.CVM_HOST }}
          username: ${{ secrets.CVM_USERNAME }}
          key: ${{ secrets.CVM_SSH_PRIVATE_KEY }}
          source: "nginx/file-processor.conf"
          target: "~/${{ secrets.CVM_USERNAME }}/evolve-file-processor"

      - name: 在服务器上构建和部署
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.CVM_HOST }}
          username: ${{ secrets.CVM_USERNAME }}
          key: ${{ secrets.CVM_SSH_PRIVATE_KEY }}
          command_timeout: 30m
          script: |
            set -e
            
            # 1. 进入项目目录
            cd ~/${{ secrets.CVM_USERNAME }}/evolve-file-processor
            
            # 2. 恢复.env文件
            if [ -f ~/${{ secrets.CVM_USERNAME }}/.env.backup ]; then
              cp ~/${{ secrets.CVM_USERNAME }}/.env.backup .env
              echo ".env文件已恢复"
            fi
            
            # 3. 检查是否需要重新构建
            REBUILD=false
            if [ -f ~/${{ secrets.CVM_USERNAME }}/requirements.backup ]; then
              if ! diff -q ~/${{ secrets.CVM_USERNAME }}/requirements.backup requirements.txt &>/dev/null; then
                echo "requirements.txt已更改，需要重新构建"
                REBUILD=true
              else
                echo "requirements.txt未更改，尝试复用现有镜像"
              fi
              # 保存当前版本用于下次比较
              cp requirements.txt ~/${{ secrets.CVM_USERNAME }}/requirements.backup
            else
              echo "未找到之前的requirements.backup，将进行完整构建"
              REBUILD=true
              cp requirements.txt ~/${{ secrets.CVM_USERNAME }}/requirements.backup
            fi
            
            # 4. 检查.env文件是否存在
            if [ ! -f .env ]; then
              echo "错误: 服务器上不存在.env文件！请先创建此文件"
              exit 1
            else
              echo ".env文件已存在，验证配置中..."
              
              # 检查必要配置是否存在（不显示内容）
              if ! grep -q "DATABASE_URL" .env; then
                echo "错误: .env文件缺少DATABASE_URL配置"
                exit 1
              fi
              
              if ! grep -q "POSTGRES_USER" .env; then
                echo "错误: .env文件缺少POSTGRES_USER配置"
                exit 1
              fi
              
              if ! grep -q "POSTGRES_PASSWORD" .env; then
                echo "错误: .env文件缺少POSTGRES_PASSWORD配置"
                exit 1
              fi
              
              if ! grep -q "POSTGRES_DB" .env; then
                echo "错误: .env文件缺少POSTGRES_DB配置"
                exit 1
              fi
              
              # 检查数据库连接是否指向正确的主机名
              if grep "localhost" .env | grep -q "DATABASE_URL"; then
                echo "警告: 发现DATABASE_URL使用localhost，临时修改为db"
                sed -i 's/localhost/db/g' .env
              fi
              
              echo ".env配置验证完成"
            fi
            
            # 5. 配置Docker设置以优化构建
            echo "配置Docker构建优化..."
            sudo mkdir -p /etc/docker
            if [ ! -f /etc/docker/daemon.json ]; then
              sudo tee /etc/docker/daemon.json > /dev/null << 'EOL'
            {
              "registry-mirrors": ["https://mirror.ccs.tencentyun.com"],
              "max-concurrent-downloads": 10,
              "log-driver": "json-file",
              "log-opts": {
                "max-size": "100m"
              },
              "storage-driver": "overlay2"
            }
            EOL
              sudo systemctl restart docker || sudo service docker restart
            fi
            
            # 6. 停止并清理所有相关容器、网络和卷
            echo "停止并清理之前的容器和相关资源..."
            # 先停止所有容器
            docker-compose down --remove-orphans || true
            
            # 尝试获取和停止可能仍在运行的相关容器
            RELATED_CONTAINERS=$(docker ps -a | grep evolve-file-processor | awk '{print $1}' || true)
            if [ ! -z "$RELATED_CONTAINERS" ]; then
              echo "发现相关容器，正在停止和移除："
              docker stop $RELATED_CONTAINERS || true
              docker rm $RELATED_CONTAINERS || true
            fi
            
            # 查找并彻底终止占用5432端口的所有进程
            echo "查找并终止占用5432端口的所有进程..."
            for i in {1..3}; do
              PORT_PROCESSES=$(sudo ss -tulpn | grep ':5432' | grep LISTEN | awk '{print $7}' | sed 's/users:((".*",pid=\([0-9]*\).*/\1/g' || true)
              if [ ! -z "$PORT_PROCESSES" ]; then
                echo "第${i}次尝试：发现进程正在使用5432端口，进程ID: $PORT_PROCESSES"
                for pid in $PORT_PROCESSES; do
                  echo "终止进程: $pid"
                  sudo kill -9 $pid || true
                done
                echo "等待端口释放 (5秒)..."
                sleep 5
              else
                echo "没有进程占用5432端口"
                break
              fi
            done
            
            # 检查是否有其他Docker容器使用该端口
            CONTAINER_USING_PORT=$(docker ps -a | grep 5432 | awk '{print $1}' || true)
            if [ ! -z "$CONTAINER_USING_PORT" ]; then
              echo "发现容器正在使用5432端口，强制停止: $CONTAINER_USING_PORT"
              docker stop $CONTAINER_USING_PORT || true
              docker rm $CONTAINER_USING_PORT || true
              sleep 3
            fi
            
            # 强制关闭端口 (关闭所有TCP连接)
            echo "强制关闭所有5432端口连接..."
            sudo ss -K dport = :5432 || true
            sleep 2
            
            # 清理无用的网络
            docker network prune -f
            
            # 重启Docker服务以释放所有端口
            echo "重启Docker服务以彻底释放端口..."
            sudo systemctl restart docker || sudo service docker restart
            sleep 5
            
            # 验证端口状态
            echo "验证端口5432状态："
            if sudo ss -tulpn | grep ':5432' | grep LISTEN; then
              echo "警告: 端口5432仍被占用,使用端口5433作为临时解决方案"
              sed -i 's/"5432:5432"/"5433:5432"/g' docker-compose.yml
              # 更新环境变量
              if grep -q ":5432" .env; then
                sed -i 's/:5432/:5433/g' .env
              elif grep -q "@db/" .env; then
                sed -i 's/@db\//@db:5433\//g' .env
              fi
            else
              echo "成功: 端口5432已释放,使用标准端口"
              # 确保docker-compose.yml使用标准端口
              sed -i 's/"5433:5432"/"5432:5432"/g' docker-compose.yml || true
              # 恢复环境变量
              if grep -q ":5433" .env; then
                sed -i 's/:5433/:5432/g' .env
              elif grep -q "@db:5433" .env; then
                sed -i 's/@db:5433\//@db\//g' .env
              fi
            fi
            
            # 确保docker-compose.yml存在
            if [ ! -f docker-compose.yml ]; then
              echo "错误: docker-compose.yml不存在!"
              exit 1
            fi
            
            # 显示要使用的配置
            echo "将使用以下配置:"
            echo "PostgreSQL端口:"
            grep -n "543[23]:5432" docker-compose.yml || echo "未找到端口配置"
            echo "数据库连接:"
            grep "DATABASE_URL" .env | sed 's/PASSWORD=.*/PASSWORD=********/g' || echo "未找到数据库连接"
            
            # 7. 在本地构建Docker镜像（仅在需要时）
            if [ "$REBUILD" = true ] || ! docker image inspect evolve-file-processor:latest &>/dev/null; then
              echo "开始构建Docker镜像..."
              # 使用Docker构建缓存
              docker build --build-arg BUILDKIT_INLINE_CACHE=1 \
                          --cache-from evolve-file-processor:latest \
                          -t evolve-file-processor:latest .
              echo "Docker镜像构建完成"
            else
              echo "复用现有Docker镜像，跳过构建步骤"
            fi
            
            # 8. 启动服务
            echo "启动服务..."
            export IMAGE_NAME=evolve-file-processor
            export IMAGE_TAG=latest
            
            # 使用--force-recreate确保容器被重新创建
            docker-compose up -d --force-recreate
            
            # 9. 检查容器状态
            echo "查看容器状态..."
            docker-compose ps
            
            # 10. 等待数据库就绪
            echo "等待数据库就绪..."
            for i in {1..12}; do
              if docker-compose exec -T db pg_isready -U postgres &>/dev/null; then
                echo "数据库已就绪!"
                break
              fi
              echo "等待数据库就绪... 尝试 $i/12"
              sleep 5
              if [ $i -eq 12 ]; then
                echo "警告：数据库启动超时，但将继续部署流程"
              fi
            done
            
            # 11. 复制Nginx配置
            echo "复制Nginx配置..."
            
            # 检查Nginx是否已安装
            if ! command -v nginx &> /dev/null; then
                echo "Nginx未安装，正在安装..."
                sudo apt-get update
                sudo apt-get install -y nginx
                echo "Nginx已安装"
            else
                echo "Nginx已存在"
            fi
            
            # 查找Nginx配置目录
            echo "查找Nginx配置目录..."
            if [ -d "/etc/nginx/conf.d" ]; then
                NGINX_CONF_DIR="/etc/nginx/conf.d"
                echo "找到标准配置目录: $NGINX_CONF_DIR"
            elif [ -d "/etc/nginx/sites-available" ]; then
                NGINX_CONF_DIR="/etc/nginx/sites-available"
                echo "找到Ubuntu配置目录: $NGINX_CONF_DIR"
            else
                # 如果找不到标准目录，创建一个
                NGINX_CONF_DIR="/etc/nginx/conf.d"
                echo "未找到标准配置目录，创建: $NGINX_CONF_DIR"
                sudo mkdir -p $NGINX_CONF_DIR
            fi
            
            # 复制配置文件
            echo "复制配置到: $NGINX_CONF_DIR/file-processor.evolving.team.conf"
            sudo cp -f nginx/file-processor.conf $NGINX_CONF_DIR/file-processor.evolving.team.conf
            
            # 如果是sites-available目录，创建符号链接到sites-enabled
            if [ "$NGINX_CONF_DIR" = "/etc/nginx/sites-available" ]; then
                echo "创建符号链接到sites-enabled目录..."
                sudo ln -sf $NGINX_CONF_DIR/file-processor.evolving.team.conf /etc/nginx/sites-enabled/
            fi
            
            # 显示配置文件内容
            echo "Nginx配置文件内容:"
            sudo cat $NGINX_CONF_DIR/file-processor.evolving.team.conf
            
            # 12. 确保Certbot已安装
            if ! command -v certbot &> /dev/null; then
                echo "安装Certbot..."
                sudo apt-get update
                sudo apt-get install -y certbot python3-certbot-nginx
                
                # 验证安装是否成功
                if ! command -v certbot &> /dev/null; then
                    echo "警告: Certbot安装失败，将跳过SSL证书配置"
                else
                    echo "Certbot安装成功"
                fi
            fi
            
            # 13. 申请/更新SSL证书（如果需要）
            if command -v certbot &> /dev/null; then
                if [ ! -d "/etc/letsencrypt/live/file-processor.evolving.team" ]; then
                    echo "申请新的SSL证书..."
                    sudo certbot --nginx -d file-processor.evolving.team --non-interactive --agree-tos -m admin@evolving.team || echo "证书申请失败，暂时使用HTTP"
                else
                    echo "检查证书更新..."
                    sudo certbot renew --nginx --non-interactive || echo "证书更新失败，使用现有证书"
                fi
            else
                echo "跳过SSL证书配置，因为Certbot未安装"
            fi
            
            # 14. 检查Nginx配置并重新加载
            if command -v nginx &> /dev/null; then
                echo "检查并重新加载Nginx配置..."
                # 显示Nginx配置信息
                echo "当前Nginx配置文件位置:"
                sudo find /etc/nginx -type f -name "*.conf" | sort
                
                # 检查FastAPI应用状态
                echo "检查FastAPI应用状态..."
                docker ps
                docker logs evolve-file-processor-api-1 --tail 20 || echo "无法获取API容器日志"
                
                # 检查网络连接
                echo "检查网络连接..."
                docker exec evolve-file-processor-api-1 curl -v http://localhost:8000/health || echo "无法从容器内部访问API"
                curl -v http://localhost:8000/health || echo "无法从主机访问API"
                
                # 检查Nginx配置
                if sudo nginx -t; then
                    sudo systemctl reload nginx || sudo service nginx reload
                    echo "Nginx配置已重新加载"
                    
                    # 显示实际使用的配置
                    echo "Nginx实际使用的配置:"
                    sudo nginx -T | grep -A 20 "file-processor"
                else
                    echo "警告: Nginx配置测试失败，创建简单的默认配置"
                    # 创建一个简单的默认配置，使用单行命令
                    echo 'server { listen 80; server_name file-processor.evolving.team; location / { proxy_pass http://localhost:8000; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; } }' | sudo tee /tmp/default.conf > /dev/null
                    
                    # 使用之前找到的配置目录
                    if [ -z "$NGINX_CONF_DIR" ]; then
                        # 如果变量未定义，使用默认目录
                        NGINX_CONF_DIR="/etc/nginx/conf.d"
                        sudo mkdir -p $NGINX_CONF_DIR
                    fi
                    
                    sudo mv /tmp/default.conf $NGINX_CONF_DIR/file-processor.evolving.team.conf
                    
                    # 如果是sites-available目录，创建符号链接到sites-enabled
                    if [ "$NGINX_CONF_DIR" = "/etc/nginx/sites-available" ]; then
                        echo "创建符号链接到sites-enabled目录..."
                        sudo ln -sf $NGINX_CONF_DIR/file-processor.evolving.team.conf /etc/nginx/sites-enabled/
                    fi
                    
                    sudo nginx -t && sudo systemctl reload nginx || echo "无法使用默认配置"
                fi
            else
                echo "跳过Nginx配置，因为Nginx未安装"
            fi
            
            # 15. 运行数据库迁移
            echo "运行数据库迁移..."
            docker-compose exec -T api alembic upgrade head || echo "数据库迁移失败，请检查日志"
            
            # 16. 清理不再使用的Docker镜像
            echo "清理未使用的Docker镜像..."
            docker system prune -f
            
            # 17. 复制并执行调试脚本
            echo "复制并执行调试脚本..."
            cp -f scripts/debug-nginx.sh /tmp/debug-nginx.sh
            chmod +x /tmp/debug-nginx.sh
            sudo /tmp/debug-nginx.sh > nginx-debug.log 2>&1
            echo "调试日志已保存到 nginx-debug.log"
            cat nginx-debug.log
            
            echo "部署完成!"
      
      # 等待服务启动
      - name: 等待服务启动
        run: sleep 15
      
      # 简单检查服务状态
      - name: 检查API服务
        run: |
          echo "检查API服务状态..."
          curl -s ${{ env.API_URL }}/health || echo "警告: 无法连接到API服务" 